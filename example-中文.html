<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibRaw Wasm 图像处理工具</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --background-color: #f5f5f5;
            --panel-color: #ffffff;
            --text-color: #333333;
            --text-secondary: #555555;
            --border-color: #dddddd;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            --radius: 8px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--background-color);
        }
        
        h1 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 30px;
            font-weight: 600;
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        h3 {
            color: var(--text-color);
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 1.1rem;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .left-panel {
            flex: 0 0 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .center-panel {
            flex: 1;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .right-panel {
            flex: 0 0 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-header h3 {
            margin: 0;
        }
        
        .file-input {
            width: 100%;
            padding: 12px;
            border: 2px dashed var(--border-color);
            border-radius: var(--radius);
            background-color: #fafafa;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-input:hover {
            border-color: var(--primary-color);
            background-color: #f0f7fb;
        }
        
        .file-input input[type="file"] {
            display: none;
        }
        
        .file-input-label {
            display: block;
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .file-input-label:hover {
            background-color: var(--secondary-color);
        }
        
        .file-name {
            margin-top: 10px;
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .image-container {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            text-align: center;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background-color: #f9f9f9;
        }
        
        .status-message {
            margin-top: 15px;
            color: var(--primary-color);
            font-style: italic;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .slider-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--secondary-color);
            transform: scale(1.1);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            background: var(--secondary-color);
            transform: scale(1.1);
        }
        
        .value-display {
            min-width: 45px;
            text-align: right;
            font-weight: 500;
            color: var(--text-color);
            font-size: 0.9rem;
        }
        
        .checkbox-group {
            margin-bottom: 15px;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.95rem;
        }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .color-adjustments {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .color-slider {
            margin-bottom: 10px;
        }
        
        .color-slider label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 5px;
        }
        
        .metadata {
            max-height: 400px;
            overflow-y: auto;
            font-size: 0.85rem;
            font-family: 'Courier New', Courier, monospace;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: none;
            color: var(--text-secondary);
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }
        
        button:hover {
            background-color: var(--secondary-color);
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .reset-button {
            background-color: #95a5a6;
        }
        
        .reset-button:hover {
            background-color: #7f8c8d;
        }
        
        /* 滤镜选择器样式 */
        .filter-group {
            margin-bottom: 15px;
        }
        
        .filter-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 5px;
        }
        
        .filter-select {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
        }
        
        .save-filter-button {
            padding: 8px 12px;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            background-color: white;
            color: var(--primary-color);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .save-filter-button:hover:not(:disabled) {
            background-color: var(--primary-color);
            color: white;
        }
        
        .save-filter-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .curve-editor {
            height: 150px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 15px;
            position: relative;
            background-color: #fafafa;
        }
        
        .perspective-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            .left-panel,
            .right-panel {
                flex: 1;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    
    <div class="container">
        <!-- 左侧面板：文件上传和基本设置 -->
        <div class="left-panel">
            <div class="panel">
                <div class="panel-header">
                    <h3>文件上传</h3>
                </div>
                <div class="file-input">
                    <input type="file" id="raw-file" accept=".cr2,.nef,.arw,.dng,.raw,.rw2">
                    <label for="raw-file" class="file-input-label">选择 RAW 文件</label>
                    <div class="file-name" id="file-name">未选择文件</div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <h3>基本设置</h3>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="use-auto-wb" checked>
                        自动白平衡
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="use-camera-wb">
                        相机白平衡
                    </label>
                </div>
                <div class="slider-group">
                    <label for="brightness">亮度</label>
                    <div class="slider-wrapper">
                        <input type="range" id="brightness" min="0.1" max="4" step="0.1" value="1">
                        <span class="value-display" id="brightness-value">1.0</span>
                    </div>
                </div>
                <div class="slider-group">
                    <label for="exposure">曝光补偿</label>
                    <div class="slider-wrapper">
                        <input type="range" id="exposure" min="-2" max="2" step="0.1" value="0">
                        <span class="value-display" id="exposure-value">0.0</span>
                    </div>
                </div>
                <div class="slider-group">
                    <label for="saturation">饱和度</label>
                    <div class="slider-wrapper">
                        <input type="range" id="saturation" min="0" max="300" step="1" value="100">
                        <span class="value-display" id="saturation-value">100</span>
                    </div>
                </div>
                
                <!-- 滤镜选择器 -->
                <div class="filter-group">
                    <label for="filter-select">预设滤镜</label>
                    <div class="filter-controls">
                        <select id="filter-select" class="filter-select">
                            <option value="none">无滤镜</option>
                        </select>
                        <button id="save-filter-button" class="save-filter-button" disabled>保存当前配置</button>
                    </div>
                </div>
                <div class="button-group">
                    <button id="apply-button" disabled>应用设置</button>
                    <button id="reset-button" class="reset-button" disabled>重置</button>
                </div>
            </div>
        </div>
        
        <!-- 中间面板：图像显示 -->
        <div class="center-panel">
            <div class="image-container">
                <canvas id="image-canvas"></canvas>
                <div class="status-message" id="status-message">请上传 RAW 文件以查看图像</div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <h3>曲线调整</h3>
                </div>
                <div class="curve-editor" id="curve-editor"></div>
                <div class="slider-group">
                    <label for="contrast">对比度</label>
                    <div class="slider-wrapper">
                        <input type="range" id="contrast" min="-50" max="50" step="1" value="0">
                        <span class="value-display" id="contrast-value">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 右侧面板：高级设置 -->
        <div class="right-panel">
            <div class="panel">
                <div class="tabs">
                    <button class="tab active" data-tab="color">颜色调整</button>
                    <button class="tab" data-tab="detail">细节处理</button>
                    <button class="tab" data-tab="perspective">透视校正</button>
                </div>
                
                <div class="tab-content active" id="color-tab">
                    <div class="color-adjustments">
                        <div class="color-slider">
                            <label for="red-tint">红色色调</label>
                            <input type="range" id="red-tint" min="-100" max="100" step="1" value="0">
                        </div>
                        <div class="color-slider">
                            <label for="green-tint">绿色色调</label>
                            <input type="range" id="green-tint" min="-100" max="100" step="1" value="0">
                        </div>
                        <div class="color-slider">
                            <label for="blue-tint">蓝色色调</label>
                            <input type="range" id="blue-tint" min="-100" max="100" step="1" value="0">
                        </div>
                        <div class="color-slider">
                            <label for="highlights">高光</label>
                            <input type="range" id="highlights" min="-50" max="50" step="1" value="0">
                        </div>
                        <div class="color-slider">
                            <label for="shadows">阴影</label>
                            <input type="range" id="shadows" min="-50" max="50" step="1" value="0">
                        </div>
                        <div class="color-slider">
                            <label for="whites">白色</label>
                            <input type="range" id="whites" min="0" max="100" step="1" value="50">
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="detail-tab">
                    <div class="slider-group">
                        <label for="sharpness">锐化</label>
                        <div class="slider-wrapper">
                            <input type="range" id="sharpness" min="0" max="100" step="1" value="0">
                            <span class="value-display" id="sharpness-value">0</span>
                        </div>
                    </div>
                    <div class="slider-group">
                        <label for="noise-reduction">减少杂色</label>
                        <div class="slider-wrapper">
                            <input type="range" id="noise-reduction" min="0" max="4" step="1" value="0">
                            <span class="value-display" id="noise-reduction-value">0</span>
                        </div>
                    </div>
                    <div class="slider-group">
                        <label for="texture">纹理/清晰度</label>
                        <div class="slider-wrapper">
                            <input type="range" id="texture" min="-50" max="50" step="1" value="0">
                            <span class="value-display" id="texture-value">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="tab-content" id="perspective-tab">
                    <div class="perspective-controls">
                        <div class="slider-group">
                            <label for="vertical-tilt">垂直倾斜</label>
                            <input type="range" id="vertical-tilt" min="-10" max="10" step="0.1" value="0">
                        </div>
                        <div class="slider-group">
                            <label for="horizontal-tilt">水平倾斜</label>
                            <input type="range" id="horizontal-tilt" min="-10" max="10" step="0.1" value="0">
                        </div>
                        <div class="slider-group">
                            <label for="rotate">旋转</label>
                            <input type="range" id="rotate" min="-180" max="180" step="1" value="0">
                        </div>
                        <div class="slider-group">
                            <label for="scale">缩放</label>
                            <input type="range" id="scale" min="50" max="200" step="1" value="100">
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <h3>图像元数据</h3>
                </div>
                <div class="metadata" id="metadata-output">请上传 RAW 文件以查看元数据</div>
            </div>
        </div>
    </div>

    <script type="module">
        import LibRaw from './index.js';
        
        // 获取DOM元素
        const rawFileInput = document.getElementById('raw-file');
        const fileName = document.getElementById('file-name');
        const metadataOutput = document.getElementById('metadata-output');
        const canvas = document.getElementById('image-canvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const applyButton = document.getElementById('apply-button');
        const resetButton = document.getElementById('reset-button');
        
        // 获取所有控件元素
        const useAutoWbCheckbox = document.getElementById('use-auto-wb');
        const useCameraWbCheckbox = document.getElementById('use-camera-wb');
        const brightnessSlider = document.getElementById('brightness');
        const brightnessValue = document.getElementById('brightness-value');
        const exposureSlider = document.getElementById('exposure');
        const exposureValue = document.getElementById('exposure-value');
        const saturationSlider = document.getElementById('saturation');
        const saturationValue = document.getElementById('saturation-value');
        const sharpnessSlider = document.getElementById('sharpness');
        const sharpnessValue = document.getElementById('sharpness-value');
        const noiseReductionSlider = document.getElementById('noise-reduction');
        const noiseReductionValue = document.getElementById('noise-reduction-value');
        const textureSlider = document.getElementById('texture');
        const textureValue = document.getElementById('texture-value');
        const contrastSlider = document.getElementById('contrast');
        const contrastValue = document.getElementById('contrast-value');
        const redTintSlider = document.getElementById('red-tint');
        const greenTintSlider = document.getElementById('green-tint');
        const blueTintSlider = document.getElementById('blue-tint');
        const highlightsSlider = document.getElementById('highlights');
        const shadowsSlider = document.getElementById('shadows');
        const whitesSlider = document.getElementById('whites');
        const verticalTiltSlider = document.getElementById('vertical-tilt');
        const horizontalTiltSlider = document.getElementById('horizontal-tilt');
        const rotateSlider = document.getElementById('rotate');
        const scaleSlider = document.getElementById('scale');
        const curveEditor = document.getElementById('curve-editor');
        const filterSelect = document.getElementById('filter-select');
        const saveFilterButton = document.getElementById('save-filter-button');
        
        // 标签页相关元素
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        // 存储默认设置
        const defaultSettings = {
            use_auto_wb: 1,
            use_camera_wb: 0,
            bright: 1.0,
            exp_shift: 0.0,
            user_sat: 100,
            fbdd_noiserd: 0,
            user_mul: [1.0, 1.0, 1.0, 1.0],
            output_color: 1,
            output_bps: 8,
            half_size: 0,
            exp_correc: 1,
            adjust_maximum_thr: 0.75,
            shadows: 0
        };
        
        // 存储滤镜预设
        let filterPresets = {
            '高对比度': {
                bright: 1.0,
                exp_shift: 0.1,
                user_sat: 120,
                highlights: 10,
                shadows: -10,
                contrast: 20
            },
            '复古胶片': {
                bright: 0.9,
                exp_shift: 0.0,
                user_sat: 110,
                highlights: -5,
                shadows: 10,
                red_tint: 5,
                green_tint: -3,
                blue_tint: -10
            },
            '风景模式': {
                bright: 1.1,
                exp_shift: 0.2,
                user_sat: 130,
                highlights: -10,
                shadows: 5,
                green_tint: 5,
                blue_tint: 5
            },
            '黑白模式': {
                bright: 1.0,
                exp_shift: 0.0,
                user_sat: 0,
                contrast: 15
            }
        };
        
        // 配置参数
        let settings = { ...defaultSettings };
        
        // 存储当前的文件数据
        let currentFileBuffer = null;
        // 缓存处理后的图像数据
        let cachedImageData = null;

        // 创建 LibRaw 实例
        const libraw = new LibRaw();
        
        // 添加防抖函数 - 优化版本
        function debounce(func, wait, immediate = false) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    timeout = null;
                    if (!immediate) func.apply(this, args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(this, args);
                return callNow; // 返回是否立即执行了函数，便于调试
            };
        }
        
        // 全局变量保存当前选择的文件对象
        let currentSelectedFile;
        
        // 初始化滤镜选择器
        function initFilterSelector() {
            // 清空现有选项（保留默认的"无滤镜"选项）
            while (filterSelect.options.length > 1) {
                filterSelect.remove(1);
            }
            
            // 添加滤镜预设选项
            for (const presetName in filterPresets) {
                const option = document.createElement('option');
                option.value = presetName;
                option.textContent = presetName;
                filterSelect.appendChild(option);
            }
        }
        
        // 应用滤镜预设
        function applyFilterPreset(presetName) {
            if (presetName === 'none' || !filterPresets[presetName]) {
                return;
            }
            
            const preset = filterPresets[presetName];
            
            // 应用预设值到设置对象
            for (const key in preset) {
                switch (key) {
                    case 'bright':
                        brightnessSlider.value = preset[key];
                        brightnessValue.textContent = preset[key].toFixed(1);
                        settings[key] = preset[key];
                        break;
                    case 'exp_shift':
                        exposureSlider.value = preset[key];
                        exposureValue.textContent = preset[key].toFixed(1);
                        settings[key] = preset[key];
                        break;
                    case 'user_sat':
                        saturationSlider.value = preset[key];
                        saturationValue.textContent = preset[key];
                        settings[key] = preset[key];
                        break;
                    case 'contrast':
                        contrastSlider.value = preset[key];
                        contrastValue.textContent = preset[key];
                        break;
                    case 'highlights':
                        highlightsSlider.value = preset[key];
                        settings[key] = preset[key];
                        break;
                    case 'shadows':
                        shadowsSlider.value = preset[key];
                        settings[key] = preset[key];
                        break;
                    case 'red_tint':
                        redTintSlider.value = preset[key];
                        break;
                    case 'green_tint':
                        greenTintSlider.value = preset[key];
                        break;
                    case 'blue_tint':
                        blueTintSlider.value = preset[key];
                        break;
                    // 添加其他需要的参数处理
                }
            }
            
            // 触发图像更新
            if (cachedImageData) {
                debouncedImageUpdate();
            }
        }
        
        // 保存当前配置为新的滤镜预设
        function saveCurrentConfigAsPreset() {
            const presetName = prompt('请输入滤镜名称:', '新滤镜' + (Object.keys(filterPresets).length + 1));
            
            if (!presetName || presetName.trim() === '') {
                alert('滤镜名称不能为空！');
                return;
            }
            
            // 获取当前所有设置
            const currentConfig = {
                bright: parseFloat(brightnessSlider.value),
                exp_shift: parseFloat(exposureSlider.value),
                user_sat: parseInt(saturationSlider.value),
                contrast: parseInt(contrastSlider.value),
                highlights: parseInt(highlightsSlider.value),
                shadows: parseInt(shadowsSlider.value),
                red_tint: parseInt(redTintSlider.value),
                green_tint: parseInt(greenTintSlider.value),
                blue_tint: parseInt(blueTintSlider.value)
                // 添加其他需要保存的参数
            };
            
            // 保存预设
            filterPresets[presetName] = currentConfig;
            
            // 更新选择器
            initFilterSelector();
            
            // 选择新保存的预设
            filterSelect.value = presetName;
            
            alert('滤镜预设 "' + presetName + '" 已保存！');
        }

        // 应用调整到缓存数据
        function applyAdjustmentsToCachedData(data, width, height) {
            // 获取当前设置
            const brightness = settings.bright;
            const contrast = parseInt(contrastSlider.value);
            const saturation = parseInt(saturationSlider.value);
            const exposure = settings.exp_shift;
            const shadows = settings.shadows !== undefined ? settings.shadows : parseInt(shadowsSlider.value);
            
            // 安全获取温度和色调滑块
            const tempSlider = document.getElementById('temperature') || document.getElementById('tempSlider');
            const tintSlider = document.getElementById('tint') || document.getElementById('tintSlider');
            const temperature = tempSlider ? parseInt(tempSlider.value) : 0;
            const tint = tintSlider ? parseInt(tintSlider.value) : 0;
            
            // 检查并应用用户自定义的白平衡系数（红、绿、蓝色调调整）
            const useUserMul = settings.user_mul && settings.user_mul.length === 4;
            
            // 预先计算所有不变的因子，避免在循环内重复计算
            const contrastFactor = contrast !== 0 ? (259 * (contrast + 255)) / (255 * (259 - contrast)) : 1;
            const exposureFactor = exposure !== 0 ? Math.pow(2, exposure) : 1;
            const saturationFactor = saturation !== 100 ? saturation / 100 : 1;
            
            // 获取高光值并检查是否需要应用高光调整
            const highlights = settings.highlights !== undefined ? settings.highlights : parseInt(highlightsSlider.value);
            // 获取白色值并检查是否需要应用白色调整
            const whites = settings.whites !== undefined ? settings.whites : parseInt(whitesSlider.value);
            
            // 标记是否需要进行某种调整，避免不必要的计算
            const needBrightness = brightness !== 1.0;
            const needContrast = contrast !== 0;
            const needSaturation = saturation !== 100;
            const needTemperature = temperature !== 0;
            const needTint = tint !== 0;
            const needExposure = exposure !== 0;
            const needShadows = shadows !== 0;
            const needHighlights = highlights !== 0;
            const needWhites = whites !== 100; // 白色滑块默认值为100
            
            // 提前检查是否有任何调整需要应用，如果没有则直接返回
            if (!needBrightness && !needContrast && !needSaturation && 
                !needTemperature && !needTint && !needExposure && !useUserMul && !needShadows && !needHighlights && !needWhites) {
                return;
            }
            
            // 使用局部变量缓存常用值，提高访问速度
            const min = Math.min;
            const max = Math.max;
            const dataLength = data.length;
            
            // 应用调整
            for (let i = 0; i < dataLength; i += 4) {
                // 提取RGB值
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];
                  
                // 应用用户自定义的白平衡系数
                if (useUserMul) {
                    r = min(255, max(0, r * settings.user_mul[0]));
                    g = min(255, max(0, g * settings.user_mul[1]));
                    b = min(255, max(0, b * settings.user_mul[2]));
                }
                  
                // 应用亮度调整
                if (needBrightness) {
                    r = min(255, max(0, r * brightness));
                    g = min(255, max(0, g * brightness));
                    b = min(255, max(0, b * brightness));
                }
                  
                // 应用对比度
                if (needContrast) {
                    r = min(255, max(0, contrastFactor * (r - 128) + 128));
                    g = min(255, max(0, contrastFactor * (g - 128) + 128));
                    b = min(255, max(0, contrastFactor * (b - 128) + 128));
                }
                  
                // 应用饱和度
                if (needSaturation) {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    r = min(255, max(0, gray + saturationFactor * (r - gray)));
                    g = min(255, max(0, gray + saturationFactor * (g - gray)));
                    b = min(255, max(0, gray + saturationFactor * (b - gray)));
                }
                  
                // 应用色温
                if (needTemperature) {
                    // 优化的色温调整算法
                    if (temperature > 0) {
                        r += temperature;
                        b -= temperature >> 1; // 使用位移运算代替除法
                    } else {
                        b -= temperature;
                        r += temperature >> 1;
                    }
                    r = min(255, max(0, r));
                    b = min(255, max(0, b));
                }
                  
                // 应用色调
                if (needTint) {
                    // 优化的色调调整算法
                    if (tint > 0) {
                        g += tint;
                        r -= tint >> 1;
                    } else {
                        r -= tint;
                        g += tint >> 1;
                    }
                    r = min(255, max(0, r));
                    g = min(255, max(0, g));
                }
                  
                // 应用曝光补偿
                if (needExposure) {
                    r = min(255, max(0, r * exposureFactor));
                    g = min(255, max(0, g * exposureFactor));
                    b = min(255, max(0, b * exposureFactor));
                }
                  
                // 应用阴影调整
                    if (needShadows) {
                        // 阴影调整算法 - 只影响暗部区域
                        const shadowThreshold = 64; // 阴影阈值
                        const shadowAdjustment = shadows / 100; // 将阴影值转换为调整系数
                        
                        // 只对低于阈值的像素应用调整
                        if (r < shadowThreshold) {
                            r = min(shadowThreshold, max(0, r + (shadowThreshold - r) * shadowAdjustment));
                        }
                        if (g < shadowThreshold) {
                            g = min(shadowThreshold, max(0, g + (shadowThreshold - g) * shadowAdjustment));
                        }
                        if (b < shadowThreshold) {
                            b = min(shadowThreshold, max(0, b + (shadowThreshold - b) * shadowAdjustment));
                        }
                    }
                    
                    // 应用高光调整
                    if (needHighlights) {
                        // 高光调整算法 - 只影响亮部区域
                        const highlightThreshold = 192; // 高光阈值
                        const highlightAdjustment = highlights / 100; // 将高光值转换为调整系数
                        
                        // 只对高于阈值的像素应用调整
                        if (r > highlightThreshold) {
                            r = max(highlightThreshold, min(255, r + (r - highlightThreshold) * highlightAdjustment));
                        }
                        if (g > highlightThreshold) {
                            g = max(highlightThreshold, min(255, g + (g - highlightThreshold) * highlightAdjustment));
                        }
                        if (b > highlightThreshold) {
                            b = max(highlightThreshold, min(255, b + (b - highlightThreshold) * highlightAdjustment));
                        }
                    }
                    
                    // 应用白色调整
                    if (needWhites) {
                        // 白色调整算法 - 只影响最亮的部分
                        const whiteThreshold = 220; // 白色阈值（比高光阈值更高）
                        const whiteAdjustment = whites / 100; // 将白色值转换为调整系数
                        
                        // 只对高于阈值的像素应用调整
                        if (r > whiteThreshold || g > whiteThreshold || b > whiteThreshold) {
                            // 计算亮度
                            const brightness = (r + g + b) / 3;
                            
                            // 仅对接近白色的像素进行调整
                            if (brightness > whiteThreshold) {
                                // 调整系数：当值大于100时增加亮度，小于100时降低亮度
                                const adjustFactor = whiteAdjustment;
                                
                                // 对RGB通道分别应用调整，保持色彩平衡
                                r = min(255, r * adjustFactor);
                                g = min(255, g * adjustFactor);
                                b = min(255, b * adjustFactor);
                            }
                        }
                    }
                  
                // 写回数据
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
                // 保持alpha不变
            }
        }

        // 从缓存更新图像
        function updateImageFromCache() {
            // 快速检查缓存数据是否存在
            if (!cachedImageData || !cachedImageData.data) {
                statusMessage.textContent = '没有缓存数据';
                return;
            }

            try {
                // 计算数据大小，避免重复访问
                const width = cachedImageData.width;
                const height = cachedImageData.height;
                const dataLength = cachedImageData.data.length;
                
                // 创建临时数组进行处理，避免直接修改缓存数据
                const tempData = new Uint8ClampedArray(dataLength);
                // 使用set方法进行批量复制，比循环复制更快
                tempData.set(cachedImageData.data);
                
                // 应用当前调整到缓存数据
                applyAdjustmentsToCachedData(tempData, width, height);
                
                // 创建ImageData对象
                const imageData = new ImageData(tempData, width, height);

                // 只在尺寸变化时才重新设置canvas尺寸，避免不必要的重绘
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }
                
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                // 应用透视和旋转变换
                applyPerspectiveTransform(imageData);
                
                // 更新状态消息（可选）
                statusMessage.textContent = '图像已从缓存更新';
                setTimeout(() => {
                    statusMessage.textContent = '';
                }, 1000);
            } catch (error) {
                console.error('从缓存更新图像失败:', error);
                statusMessage.textContent = '缓存加载失败';
            }
        }
        
        // 监听文件选择
        rawFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            // 保存当前选择的文件对象
            currentSelectedFile = file;
            
            // 显示文件名
            fileName.textContent = file.name;
            
            try {
                // 读取文件数据
                const arrayBuffer = await readFileAsArrayBuffer(file);
                
                // 创建一个 Uint8Array 视图用于传递给 Web Worker
                currentFileBuffer = new Uint8Array(arrayBuffer);
                
                // 启用按钮
                applyButton.disabled = false;
                resetButton.disabled = false;
                
                // 显示处理状态
                statusMessage.textContent = '正在处理 RAW 文件...';
                metadataOutput.textContent = '正在提取元数据...';
                
                // 使用新设置重新打开文件
                await libraw.open(currentFileBuffer, settings);
                
                // 获取元数据
                const metadata = await libraw.metadata(true);
                metadataOutput.textContent = JSON.stringify(metadata, null, 2);
                
                // 获取并缓存图像数据
                try {
                    const imageData = await libraw.imageData();
                    if (imageData && imageData.data) {
                        // 处理RGB转RGBA的通道转换
                        let rgbaData = imageData.data;
                        if (imageData.colors === 3) {
                            // RGB转RGBA
                            rgbaData = new Uint8ClampedArray(imageData.data.length * 4 / 3);
                            for (let i = 0, j = 0; i < imageData.data.length; i += 3, j += 4) {
                                rgbaData[j] = imageData.data[i];     // R
                                rgbaData[j + 1] = imageData.data[i + 1]; // G
                                rgbaData[j + 2] = imageData.data[i + 2]; // B
                                rgbaData[j + 3] = 255;              // A (不透明)
                            }
                        }
                        
                        // 创建缓存的ImageData对象
                        cachedImageData = {
                            data: new Uint8ClampedArray(rgbaData),
                            width: imageData.width,
                            height: imageData.height
                        };
                    }
                } catch (error) {
                    console.error('缓存图像数据失败:', error);
                }
            // 显示初始图像
            updateImageFromCache();
                
                // 隐藏处理状态
                statusMessage.textContent = '处理完成';
                setTimeout(() => {
                    statusMessage.textContent = '';
                }, 2000);
            } catch (error) {
                console.error('处理文件时出错:', error);
                statusMessage.textContent = '处理失败';
                metadataOutput.textContent = `处理文件时出错: ${error.message}`;
            }
        });
        
        // 应用按钮点击事件
        applyButton.addEventListener('click', async () => {
            updateImageWithNewSettings();
        });
        
        // 重置按钮点击事件
        resetButton.addEventListener('click', () => {
            // 重置设置
            settings = { ...defaultSettings };
            
            // 重置控件值
            useAutoWbCheckbox.checked = true;
            useCameraWbCheckbox.checked = false;
            brightnessSlider.value = 1.0;
            brightnessValue.textContent = '1.0';
            exposureSlider.value = 0.0;
            exposureValue.textContent = '0.0';
            saturationSlider.value = 100;
            saturationValue.textContent = '100';
            sharpnessSlider.value = 0;
            sharpnessValue.textContent = '0';
            noiseReductionSlider.value = 0;
            noiseReductionValue.textContent = '0';
            textureSlider.value = 0;
            textureValue.textContent = '0';
            contrastSlider.value = 0;
            contrastValue.textContent = '0';
            redTintSlider.value = 0;
            greenTintSlider.value = 0;
            blueTintSlider.value = 0;
            highlightsSlider.value = 0;
            shadowsSlider.value = 0;
            whitesSlider.value = 100;
            verticalTiltSlider.value = 0;
            horizontalTiltSlider.value = 0;
            rotateSlider.value = 0;
            scaleSlider.value = 100;
            
            // 重新应用设置
            updateImageWithNewSettings();
        });
        
        // 监听控件变化
        useAutoWbCheckbox.addEventListener('change', (e) => {
            settings.use_auto_wb = e.target.checked ? 1 : 0;
            if (e.target.checked) {
                useCameraWbCheckbox.checked = false;
                settings.use_camera_wb = 0;
            }
        });
        
        useCameraWbCheckbox.addEventListener('change', (e) => {
            settings.use_camera_wb = e.target.checked ? 1 : 0;
            if (e.target.checked) {
                useAutoWbCheckbox.checked = false;
                settings.use_auto_wb = 0;
            }
        });
        
        brightnessSlider.addEventListener('input', (e) => {
            settings.bright = parseFloat(e.target.value);
            brightnessValue.textContent = settings.bright.toFixed(1);
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        exposureSlider.addEventListener('input', (e) => {
            settings.exp_shift = parseFloat(e.target.value);
            exposureValue.textContent = settings.exp_shift.toFixed(1);
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        saturationSlider.addEventListener('input', (e) => {
            settings.user_sat = parseInt(e.target.value);
            saturationValue.textContent = settings.user_sat;
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        noiseReductionSlider.addEventListener('input', (e) => {
            settings.fbdd_noiserd = parseInt(e.target.value);
            noiseReductionValue.textContent = settings.fbdd_noiserd;
        });
        
        sharpnessSlider.addEventListener('input', (e) => {
            sharpnessValue.textContent = e.target.value;
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        textureSlider.addEventListener('input', (e) => {
            textureValue.textContent = e.target.value;
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        contrastSlider.addEventListener('input', (e) => {
            contrastValue.textContent = e.target.value;
            // 使用防抖处理的图像更新
            debouncedImageUpdate();
        });
        
        // 标签页切换
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // 移除所有活动状态
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // 添加当前活动状态
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });
        
        // 为阴影滑块添加事件监听器
        shadowsSlider.addEventListener('input', function() {
            settings.shadows = parseInt(this.value);
            debouncedImageUpdate();
        });
        
        // 为高光滑块添加事件监听器
        highlightsSlider.addEventListener('input', function() {
            settings.highlights = parseInt(this.value);
            debouncedImageUpdate();
        });
        
        // 为白色滑块添加事件监听器
        whitesSlider.addEventListener('input', function() {
            settings.whites = parseInt(this.value);
            debouncedImageUpdate();
        });
        
        // 创建统一的防抖图像处理函数
        const debouncedImageUpdate = debounce(() => {
            if (cachedImageData) {
                updateImageFromCache();
            }
        }, 66); // 约15fps的刷新率，平衡响应速度和性能
        
        // 防抖处理颜色调整
        const debouncedColorUpdate = debounce(() => {
            updateWhiteBalanceCoefficients();
            if (cachedImageData) {
                debouncedImageUpdate();
            }
        }, 300);
        
        redTintSlider.addEventListener('input', debouncedColorUpdate);
        greenTintSlider.addEventListener('input', debouncedColorUpdate);
        blueTintSlider.addEventListener('input', debouncedColorUpdate);
        
        // 更新白平衡系数
        function updateWhiteBalanceCoefficients() {
            const redTint = parseInt(redTintSlider.value);
            const greenTint = parseInt(greenTintSlider.value);
            const blueTint = parseInt(blueTintSlider.value);
            
            // 基础值为1.0，调整范围为±100%
            const redMultiplier = 1.0 + (redTint / 100);
            const greenMultiplier = 1.0 + (greenTint / 100);
            const blueMultiplier = 1.0 + (blueTint / 100);
            
            // user_mul 是一个4元素数组，通常用于[R, G, B, G]的调整
            settings.user_mul = [redMultiplier, greenMultiplier, blueMultiplier, greenMultiplier];
        }
        
        // 读取文件为 ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsArrayBuffer(file);
            });
        }
        
        // 使用新设置更新图像
        async function updateImageWithNewSettings() {
            if (!currentSelectedFile) return;
            
            try {
                statusMessage.textContent = '应用设置...';
                
                // 重新从文件读取数据，避免使用可能已被分离的 ArrayBuffer
                const arrayBuffer = await readFileAsArrayBuffer(currentSelectedFile);
                const bufferCopy = new Uint8Array(arrayBuffer);
                
                // 使用新设置重新打开文件
                await libraw.open(bufferCopy, settings);
                
                // 更新图像显示
                updateImageFromCache();
                
                statusMessage.textContent = '设置已应用';
                setTimeout(() => {
                    statusMessage.textContent = '';
                }, 1500);
            } catch (error) {
                console.error('应用新设置时出错:', error);
                statusMessage.textContent = '应用设置失败';
            }
        }
        
        // 更新图像显示
        async function updateImage() {
            try {
                // 优先使用缓存数据
                if (cachedImageData && cachedImageData.data) {
                    // 直接使用缓存数据进行渲染
                    updateImageFromCache();
                    return;
                }
                
                // 如果没有缓存，从libraw获取图像数据
                const imageData = await libraw.imageData();
                
                if (!imageData || !imageData.data) {
                    console.error('无法获取图像数据');
                    return;
                }
                
                // 设置 canvas 尺寸
                canvas.width = imageData.width;
                canvas.height = imageData.height;
                
                // 创建 ImageData 对象并绘制到 canvas
                // 处理 RGB 转 RGBA 格式转换
                if (imageData.colors === 3) {
                    // RGB 转 RGBA
                    const rgbaData = new Uint8ClampedArray(imageData.data.length * 4 / 3);
                    for (let i = 0, j = 0; i < imageData.data.length; i += 3, j += 4) {
                        rgbaData[j] = imageData.data[i];     // R
                        rgbaData[j + 1] = imageData.data[i + 1]; // G
                        rgbaData[j + 2] = imageData.data[i + 2]; // B
                        rgbaData[j + 3] = 255;              // A (不透明)
                    }
                    
                    // 应用对比度调整
                    const contrast = parseInt(contrastSlider.value);
                    if (contrast !== 0) {
                        applyContrast(rgbaData, contrast);
                    }
                    
                    // 应用锐化和清晰度调整
                    const sharpness = parseInt(sharpnessSlider.value);
                    const texture = parseInt(textureSlider.value);
                    if (sharpness > 0 || texture > 0) {
                        applyUnsharpMask(rgbaData, imageData.width, imageData.height, sharpness, texture);
                    }
                    
                    // 创建ImageData对象
                    const canvasImageData = ctx.createImageData(imageData.width, imageData.height);
                    canvasImageData.data.set(rgbaData);
                    
                    // 应用透视和旋转调整
                    // 由于 applyPerspectiveTransform 函数会直接绘制到主画布，我们需要先清空主画布
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // 调用 applyPerspectiveTransform 函数应用变换并绘制到主画布
                    applyPerspectiveTransform(canvasImageData);
                } else {
                    // 已经是 RGBA 格式
                    const canvasImageData = ctx.createImageData(imageData.width, imageData.height);
                    canvasImageData.data.set(imageData.data);
                    ctx.putImageData(canvasImageData, 0, 0);
                }
            } catch (error) {
                console.error('更新图像时出错:', error);
            }
        }
        
        // 应用对比度调整
        function applyContrast(rgbaData, contrast) {
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            
            for (let i = 0; i < rgbaData.length; i += 4) {
                rgbaData[i] = Math.min(255, Math.max(0, factor * (rgbaData[i] - 128) + 128));
                rgbaData[i + 1] = Math.min(255, Math.max(0, factor * (rgbaData[i + 1] - 128) + 128));
                rgbaData[i + 2] = Math.min(255, Math.max(0, factor * (rgbaData[i + 2] - 128) + 128));
            }
        }
        
        // 应用锐化（简化版的非锐化蒙版）
        function applyUnsharpMask(rgbaData, width, height, sharpness, texture) {
            if (sharpness === 0 && texture === 0) return;
            
            // 创建临时数组以存储处理前的像素值
            const tempData = new Uint8ClampedArray(rgbaData);
            
            const strength = (sharpness + texture) / 100;
            
            // 对每个像素应用非锐化蒙版（跳过边缘像素）
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // 计算周围像素的平均值
                    let avgR = 0, avgG = 0, avgB = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            if (kx === 0 && ky === 0) continue; // 跳过中心像素
                            const neighborIdx = ((y + ky) * width + (x + kx)) * 4;
                            avgR += tempData[neighborIdx];
                            avgG += tempData[neighborIdx + 1];
                            avgB += tempData[neighborIdx + 2];
                        }
                    }
                    avgR /= 8;
                    avgG /= 8;
                    avgB /= 8;
                    
                    // 计算锐化值
                    const currentR = tempData[idx];
                    const currentG = tempData[idx + 1];
                    const currentB = tempData[idx + 2];
                    
                    // 应用锐化
                    rgbaData[idx] = Math.min(255, Math.max(0, currentR + (currentR - avgR) * strength));
                    rgbaData[idx + 1] = Math.min(255, Math.max(0, currentG + (currentG - avgG) * strength));
                    rgbaData[idx + 2] = Math.min(255, Math.max(0, currentB + (currentB - avgB) * strength));
                }
            }
        }
        
        // 应用透视和旋转变换
        function applyPerspectiveTransform(imageData) {
            // 获取当前变换参数
            const verticalTilt = parseFloat(verticalTiltSlider.value);
            const horizontalTilt = parseFloat(horizontalTiltSlider.value);
            const rotation = parseInt(rotateSlider.value);
            const scale = parseInt(scaleSlider.value) / 100;
            
            // 缓存常用值
            const width = imageData.width;
            const height = imageData.height;
            
            // 如果没有变换需要应用，直接绘制到画布
            if (verticalTilt === 0 && horizontalTilt === 0 && rotation === 0 && scale === 1) {
                // 直接绘制而不创建临时canvas，提高性能
                ctx.putImageData(imageData, 0, 0);
                return;
            }
            
            // 只有在需要变换时才创建临时canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 绘制图像数据到临时canvas
            tempCtx.putImageData(imageData, 0, 0);
            
            // 缓存canvas中心坐标
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 保存当前状态
            ctx.save();
            
            // 移动到画布中心
            ctx.translate(centerX, centerY);
            
            // 应用旋转（如果有）
            if (rotation !== 0) {
                ctx.rotate((rotation * Math.PI) / 180);
            }
            
            // 应用缩放（如果有）
            if (scale !== 1) {
                ctx.scale(scale, scale);
            }
            
            // 应用透视变换（如果有）
            if (verticalTilt !== 0 || horizontalTilt !== 0) {
                // 使用正确的6参数2D变换矩阵格式
                ctx.transform(1, verticalTilt/5000, horizontalTilt/5000, 1, 0, 0);
            }
            
            // 绘制图像（从中心偏移回原点）
            ctx.drawImage(tempCanvas, -width / 2, -height / 2);
            
            // 恢复状态
            ctx.restore();
        }
        
        // 初始化曲线编辑器（简化版）
        function initCurveEditor() {
            const rect = curveEditor.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            // 创建临时canvas用于绘制曲线
            const curveCanvas = document.createElement('canvas');
            curveCanvas.width = width;
            curveCanvas.height = height;
            curveCanvas.style.position = 'absolute';
            curveCanvas.style.top = '0';
            curveCanvas.style.left = '0';
            curveEditor.appendChild(curveCanvas);
            
            const curveCtx = curveCanvas.getContext('2d');
            
            // 绘制网格和对角线
            function drawCurve() {
                // 清空画布
                curveCtx.clearRect(0, 0, width, height);
                
                // 移除网格绘制代码
                
                // 绘制对角线（默认曲线）
                const rootStyle = getComputedStyle(document.documentElement);
                curveCtx.strokeStyle = rootStyle.getPropertyValue('--primary-color');
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                curveCtx.moveTo(0, height);
                curveCtx.lineTo(width, 0);
                curveCtx.stroke();
            }
            
            // 初始化绘制
            drawCurve();
        }
        
        // 初始化曲线编辑器
        window.addEventListener('load', () => {
            initCurveEditor();
            initFilterSelector();
        });
        
        // 为滤镜选择器添加事件监听器
        filterSelect.addEventListener('change', (e) => {
            applyFilterPreset(e.target.value);
        });
        
        // 为保存滤镜按钮添加事件监听器
        saveFilterButton.addEventListener('click', saveCurrentConfigAsPreset);
        
        // 当图像加载后启用保存滤镜按钮
        rawFileInput.addEventListener('change', () => {
            saveFilterButton.disabled = false;
        });
        
        // 当重置设置时，重置滤镜选择器
        resetButton.addEventListener('click', () => {
            filterSelect.value = 'none';
        });
        
        // 实现点击图像容器查看大图功能
        const imageContainer = document.querySelector('.image-container');
        
        // 创建全屏预览模态框
        function createFullscreenModal() {
            // 检查模态框是否已存在
            if (document.getElementById('fullscreen-modal')) {
                return document.getElementById('fullscreen-modal');
            }
            
            // 创建模态框容器
            const modal = document.createElement('div');
            modal.id = 'fullscreen-modal';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            modal.style.display = 'none';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '1000';
            modal.style.cursor = 'pointer';
            modal.style.transition = 'opacity 0.3s ease';
            
            // 创建关闭按钮
            const closeButton = document.createElement('button');
            closeButton.textContent = '×';
            closeButton.style.position = 'absolute';
            closeButton.style.top = '20px';
            closeButton.style.right = '30px';
            closeButton.style.fontSize = '40px';
            closeButton.style.color = 'white';
            closeButton.style.backgroundColor = 'transparent';
            closeButton.style.border = 'none';
            closeButton.style.cursor = 'pointer';
            closeButton.style.outline = 'none';
            closeButton.style.userSelect = 'none';
            closeButton.style.zIndex = '1001';
            
            // 创建显示图像的容器
            const imageWrapper = document.createElement('div');
            imageWrapper.style.maxWidth = '90%';
            imageWrapper.style.maxHeight = '90%';
            imageWrapper.style.overflow = 'hidden';
            
            // 创建用于显示大图的canvas
            const fullscreenCanvas = document.createElement('canvas');
            fullscreenCanvas.id = 'fullscreen-canvas';
            fullscreenCanvas.style.maxWidth = '100%';
            fullscreenCanvas.style.maxHeight = '100vh';
            fullscreenCanvas.style.boxShadow = '0 0 30px rgba(255, 255, 255, 0.3)';
            
            // 组装元素
            imageWrapper.appendChild(fullscreenCanvas);
            modal.appendChild(closeButton);
            modal.appendChild(imageWrapper);
            document.body.appendChild(modal);
            
            // 添加关闭事件
            function closeModal() {
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }
            
            closeButton.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // 添加ESC键关闭功能
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.style.display === 'flex') {
                    closeModal();
                }
            });
            
            return modal;
        }
        
        // 显示全屏预览
        function showFullscreenPreview() {
            // 只有当有图像数据时才显示预览
            if (!cachedImageData || !cachedImageData.data) {
                return;
            }
            
            // 创建或获取模态框
            const modal = createFullscreenModal();
            const fullscreenCanvas = document.getElementById('fullscreen-canvas');
            const fullscreenCtx = fullscreenCanvas.getContext('2d');
            
            // 设置全屏canvas尺寸为原始图像尺寸
            fullscreenCanvas.width = cachedImageData.width;
            fullscreenCanvas.height = cachedImageData.height;
            
            // 创建临时数组进行处理，避免直接修改缓存数据
            const tempData = new Uint8ClampedArray(cachedImageData.data.length);
            tempData.set(cachedImageData.data);
            
            // 应用当前调整到缓存数据
            applyAdjustmentsToCachedData(tempData, cachedImageData.width, cachedImageData.height);
            
            // 创建ImageData对象
            const imageData = new ImageData(tempData, cachedImageData.width, cachedImageData.height);
            
            // 清空画布并绘制图像
            fullscreenCtx.clearRect(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
            fullscreenCtx.putImageData(imageData, 0, 0);
            
            // 显示模态框
            modal.style.display = 'flex';
            // 强制重排以启用过渡效果
            void modal.offsetWidth;
            modal.style.opacity = '1';
        }
        
        // 为图像容器添加点击事件监听器
        imageContainer.addEventListener('click', showFullscreenPreview);
        
        // 为了提升用户体验，添加鼠标悬停效果
        imageContainer.style.cursor = 'pointer';
        imageContainer.style.transition = 'transform 0.2s ease';
        
        imageContainer.addEventListener('mouseenter', () => {
            if (cachedImageData && cachedImageData.data) {
                imageContainer.style.transform = 'scale(1.01)';
            }
        });
        
        imageContainer.addEventListener('mouseleave', () => {
            imageContainer.style.transform = 'scale(1)';
        });
    </script>
</body>
</html>