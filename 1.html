<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒæ»‘å—é¢œè‰²æ¸å˜é€‰æ‹©å™¨</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            text-align: center;
            width: 360px;
            max-width: 90%;
        }
        h1 {
            margin: 0 0 20px;
            color: #333;
            font-size: 1.25rem;
            font-weight: 500;
        }
        .color-inputs {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }
        .color-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        input[type="color"] {
            width: 48px;
            height: 36px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            padding: 2px;
            background: white;
        }
        label {
            font-size: 0.875rem;
            color: #555;
        }
        .range-wrapper {
            position: relative;
            width: 100%;
            height: 36px;
            margin-bottom: 24px;
        }
        .gradient-track {
            position: absolute;
            width: calc(100% - 24px);
            height: 8px;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 4px;
            background: linear-gradient(to right, #ff0000, #0000ff);
        }
        .range-slider {
            position: absolute;
            width: calc(100% - 24px);
            left: 12px;
            height: 100%;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            z-index: 2;
            pointer-events: none;
            margin: 0;
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 2px solid #4a4a4a;
            cursor: pointer;
            z-index: 3;
            pointer-events: auto;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .color-preview {
            width: 100%;
            height: 48px;
            border-radius: 6px;
            margin-bottom: 16px;
            border: 1px solid #e0e0e0;
        }
        .action-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #f0f0f0;
            color: #333;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }
        button:hover {
            background: #e0e0e0;
        }
        
        /* å›¾ç‰‡ä¸Šä¼ åŒºåŸŸæ ·å¼ */
        .image-upload-section {
            margin: 20px 0;
            text-align: center;
        }
        
        .upload-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
        }
        
        .upload-btn:hover {
            background: #0056b3;
        }
        
        .restore-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
            margin-left: 10px;
        }
        
        .restore-btn:hover {
            background: #545b62;
        }
        
        /* Canvaså®¹å™¨æ ·å¼ */
        .canvas-container {
            margin: 20px 0;
            text-align: center;
        }
        
        #imageCanvas {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <table border="1" cellpadding="8" cellspacing="0" id="colorTable" style="margin-bottom: 20px; border-collapse: collapse; width: 100%; max-width: 800px;">
        <thead>
            <tr style="background-color: #f5f5f5;">
                <th style="border: 1px solid #ddd; padding: 8px;">å¤´éƒ¨é¢œè‰²</th>
                <th style="border: 1px solid #ddd; padding: 8px;">å°¾éƒ¨é¢œè‰²</th>
                <th style="border: 1px solid #ddd; padding: 8px;">æ··åˆé¢œè‰²</th>
                <th style="border: 1px solid #ddd; padding: 8px;">æ··åˆæ¯”ä¾‹</th>
                <th style="border: 1px solid #ddd; padding: 8px;">æ“ä½œ</th>
            </tr>
        </thead>
        <tbody id="colorTableBody">
        </tbody>
    </table>
    <div class="container">
        <div class="color-inputs">
            <div class="color-input-group">
                <input type="color" id="color1" value="#ff0000">
                <label for="color1">å·¦ä¾§é¢œè‰²</label>
            </div>
            <div class="color-input-group">
                <input type="color" id="color2" value="#0000ff">
                <label for="color2">å³ä¾§é¢œè‰²</label>
            </div>
        </div>
        
        <div class="range-wrapper" id="rangeContainer">
            <div class="gradient-track" id="gradientTrack"></div>
            <input type="range" id="slider1" class="range-slider" min="0" max="100" value="0">
            <input type="range" id="slider2" class="range-slider" min="0" max="100" value="100">
        </div>
        
        <div class="color-preview" id="colorPreview"></div>
        
        <div class="action-buttons">
            <input type="color" id="mixColorInput" value="#ffffff">
            <button id="mixButton">æ··åˆ</button>
            <button id="undoButton">æ’¤é”€</button>
            <button id="confirmButton">ç¡®å®š</button>
        </div>
        
        <!-- å›¾ç‰‡ä¸Šä¼ åŒºåŸŸ -->
        <div class="image-upload-section">
            <input type="file" id="imageUpload" accept="image/*" style="display: none;">
            <button id="uploadButton" class="upload-btn">ä¸Šä¼ å›¾ç‰‡</button>
            <button id="restoreButton" class="restore-btn" style="display: none;">æ¢å¤åŸå›¾</button>
        </div>
        
        <!-- CanvasåŒºåŸŸ -->
        <div class="canvas-container">
            <canvas id="imageCanvas" width="400" height="300"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const color1 = document.getElementById('color1');
            const color2 = document.getElementById('color2');
            const slider1 = document.getElementById('slider1');
            const slider2 = document.getElementById('slider2');
            const gradientTrack = document.getElementById('gradientTrack');
            const colorPreview = document.getElementById('colorPreview');
            const rangeContainer = document.getElementById('rangeContainer');
            const mixColorInput = document.getElementById('mixColorInput');
            const mixButton = document.getElementById('mixButton');
            const undoButton = document.getElementById('undoButton');
            const confirmButton = document.getElementById('confirmButton');
            const colorTableBody = document.getElementById('colorTableBody');
            const imageUpload = document.getElementById('imageUpload');
            const uploadButton = document.getElementById('uploadButton');
            const restoreButton = document.getElementById('restoreButton');
            const imageCanvas = document.getElementById('imageCanvas');
            const ctx = imageCanvas.getContext('2d');
            
            let originalColor = '';
            let editingRowIndex = -1; // ç”¨äºè·Ÿè¸ªæ­£åœ¨ç¼–è¾‘çš„è¡Œ
            let originalImageData = null; // ä¿å­˜åŸå§‹å›¾ç‰‡æ•°æ®
            let colorChangeHistory = []; // ä¿å­˜æ¯æ¬¡é¢œè‰²å˜åŒ–çš„è®°å½•

            function updateGradient() {
                gradientTrack.style.background = `linear-gradient(to right, ${color1.value}, ${color2.value})`;
            }

            function enforceSliderOrder() {
                if (+slider1.value > +slider2.value) {
                    [slider1.value, slider2.value] = [slider2.value, slider1.value];
                }
            }

            function hexToRgb(hex) {
                hex = hex.replace(/^#/, '');
                const bigint = parseInt(hex, 16);
                return {
                    r: (bigint >> 16) & 255,
                    g: (bigint >> 8) & 255,
                    b: bigint & 255
                };
            }

            function rgbToHex(r, g, b) {
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            }

            function mixColors(color1, color2) {
                // ç®€å•çš„50/50æ··åˆ
                const rgb1 = hexToRgb(color1);
                const rgb2 = hexToRgb(color2);
                
                const r = Math.round((rgb1.r + rgb2.r) / 2);
                const g = Math.round((rgb1.g + rgb2.g) / 2);
                const b = Math.round((rgb1.b + rgb2.b) / 2);
                
                return rgbToHex(r, g, b);
            }

            function getGradientColor(color1, color2, position) {
                const rgb1 = hexToRgb(color1);
                const rgb2 = hexToRgb(color2);
                const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * position);
                const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * position);
                const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * position);
                return rgbToHex(r, g, b);
            }

            function updateColorPreview() {
                const midPosition = (+slider1.value + +slider2.value) / 200;
                colorPreview.style.backgroundColor = getGradientColor(color1.value, color2.value, midPosition);
            }

            function showHoverColor(e) {
                const rect = rangeContainer.getBoundingClientRect();
                const pos = Math.max(0, Math.min(1, (e.clientX - rect.left - 12) / (rect.width - 24)));
                colorPreview.style.backgroundColor = getGradientColor(color1.value, color2.value, pos);
            }

            [color1, color2].forEach(el => el.addEventListener('input', () => {
                updateGradient();
                updateColorPreview();
            }));

            [slider1, slider2].forEach(el => el.addEventListener('input', () => {
                enforceSliderOrder();
                updateColorPreview();
            }));

            mixButton.addEventListener('click', function() {
                // ä¿å­˜å½“å‰é¢„è§ˆé¢œè‰²ä½œä¸ºåŸå§‹é¢œè‰²
                originalColor = colorPreview.style.backgroundColor;
                
                // è·å–mixColorInputçš„å€¼
                const mixColor = mixColorInput.value;
                
                if (mixColor) {
                    // è·å–å½“å‰é¢„è§ˆé¢œè‰²
                    let currentColor = colorPreview.style.backgroundColor;
                    
                    // å¦‚æœbackgroundColorä¸ºç©ºï¼Œè¯´æ˜æ˜¯åˆå§‹çŠ¶æ€ï¼Œéœ€è¦è®¡ç®—å½“å‰æ»‘å—ä½ç½®çš„é¢œè‰²
                    if (!currentColor) {
                        const midPosition = (+slider1.value + +slider2.value) / 200;
                        currentColor = getGradientColor(color1.value, color2.value, midPosition);
                    } else {
                        // æå–RGBå€¼å¹¶è½¬æ¢å›HEX
                        const rgb = currentColor.match(new RegExp("\\d+", "g"));
                        if (rgb) {
                            currentColor = rgbToHex(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]));
                        }
                    }
                    
                    // æ··åˆé¢œè‰²
                    const mixedColor = mixColors(currentColor, mixColor);
                    
                    // æ›´æ–°é¢œè‰²é¢„è§ˆ
                    colorPreview.style.backgroundColor = mixedColor;
                }
            });

            undoButton.addEventListener('click', function() {
                if (originalColor) {
                    // æ¢å¤åŸå§‹é¢œè‰²
                    colorPreview.style.backgroundColor = originalColor;
                }
            });

            // ç¡®å®šæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            confirmButton.addEventListener('click', function() {
                // æ£€æŸ¥canvasæ˜¯å¦æœ‰å›¾ç‰‡
                if (isCanvasEmpty()) {
                    alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡åˆ°canvasï¼');
                    return;
                }
                
                const headColor = color1.value;
                const tailColor = color2.value;
                const mixedColor = mixColorInput.value;
                
                // ä»canvasä¸­æ‰¾åˆ°ä»å¤´éƒ¨é¢œè‰²åˆ°å°¾éƒ¨é¢œè‰²èŒƒå›´å†…çš„æ‰€æœ‰é¢œè‰²
                const colorsInRange = findColorsInRange(headColor, tailColor);
                
                if (colorsInRange.length === 0) {
                    alert('åœ¨å›¾ç‰‡ä¸­æœªæ‰¾åˆ°æŒ‡å®šé¢œè‰²èŒƒå›´å†…çš„é¢œè‰²ï¼');
                    return;
                }
                
                // å¯¹è¿™äº›é¢œè‰²è¿›è¡Œæ··åˆ
                const mixedResult = mixColorsInRange(colorsInRange, mixedColor);
                
                // å°†æ··åˆåçš„é¢œè‰²æ›´æ–°åˆ°canvasä¸Š
                const result = updateCanvasWithMixedColors(colorsInRange, mixedResult);
                
                // æ˜¾ç¤ºå¤„ç†ç»“æœ
                displayProcessingResult(result.replacedPixels);
                
                const ratio = Math.round((+slider1.value + +slider2.value) / 2) + '%';
                
                if (editingRowIndex >= 0) {
                    // ç¼–è¾‘æ¨¡å¼ï¼šæ›´æ–°ç°æœ‰è¡Œ
                    updateTableRow(editingRowIndex, headColor, tailColor, mixedColor, ratio, result.changeId);
                    editingRowIndex = -1; // é‡ç½®ç¼–è¾‘çŠ¶æ€
                    confirmButton.textContent = 'ç¡®å®š';
                } else {
                    // æ·»åŠ æ–°è¡Œ
                    addTableRow(headColor, tailColor, mixedColor, ratio, result.changeId);
                }
            });

            rangeContainer.addEventListener('mousemove', showHoverColor);
            rangeContainer.addEventListener('mouseleave', updateColorPreview);
            
            // ç‚¹å‡»æ»‘åŠ¨æ¡ç¡®è®¤é¢œè‰²
            rangeContainer.addEventListener('click', (e) => {
                const rect = rangeContainer.getBoundingClientRect();
                const pos = Math.max(0, Math.min(1, (e.clientX - rect.left - 12) / (rect.width - 24)));
                const confirmedColor = getGradientColor(color1.value, color2.value, pos);
                colorPreview.style.backgroundColor = confirmedColor;
            });

            // æ·»åŠ è¡¨æ ¼è¡Œ
            function addTableRow(headColor, tailColor, mixedColor, ratio, changeId) {
                const row = document.createElement('tr');
                row.setAttribute('data-change-id', changeId); // å­˜å‚¨å˜åŒ–ID
                row.innerHTML = `
                    <td style="border: 1px solid #ddd; padding: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; background-color: ${headColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                            <span>${headColor.toUpperCase()}</span>
                        </div>
                    </td>
                    <td style="border: 1px solid #ddd; padding: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; background-color: ${tailColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                            <span>${tailColor.toUpperCase()}</span>
                        </div>
                    </td>
                    <td style="border: 1px solid #ddd; padding: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 20px; height: 20px; background-color: ${mixedColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                            <span>${mixedColor}</span>
                        </div>
                    </td>
                    <td style="border: 1px solid #ddd; padding: 8px;">${ratio}</td>
                    <td style="border: 1px solid #ddd; padding: 8px;">
                        <button onclick="editRow(${colorTableBody.children.length})" style="margin-right: 5px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">ç¼–è¾‘</button>
                        <button onclick="deleteRow(${colorTableBody.children.length})" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">åˆ é™¤</button>
                    </td>
                `;
                colorTableBody.appendChild(row);
            }

            // æ›´æ–°è¡¨æ ¼è¡Œ
            function updateTableRow(index, headColor, tailColor, mixedColor, ratio, changeId) {
                const row = colorTableBody.children[index];
                if (row) {
                    row.setAttribute('data-change-id', changeId); // æ›´æ–°å˜åŒ–ID
                    row.innerHTML = `
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 20px; height: 20px; background-color: ${headColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                                <span>${headColor.toUpperCase()}</span>
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 20px; height: 20px; background-color: ${tailColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                                <span>${tailColor.toUpperCase()}</span>
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 20px; height: 20px; background-color: ${mixedColor}; border: 1px solid #ccc; border-radius: 3px;"></div>
                                <span>${mixedColor}</span>
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 8px;">${ratio}</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">
                            <button onclick="editRow(${index})" style="margin-right: 5px; padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">ç¼–è¾‘</button>
                            <button onclick="deleteRow(${index})" style="padding: 4px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">åˆ é™¤</button>
                        </td>
                    `;
                }
            }

            // ç¼–è¾‘è¡Œå‡½æ•°
            window.editRow = function(index) {
                const row = colorTableBody.children[index];
                if (row) {
                    const cells = row.children;
                    const headColor = cells[0].querySelector('span').textContent.toLowerCase();
                    const tailColor = cells[1].querySelector('span').textContent.toLowerCase();
                    const mixedColor = cells[2].querySelector('span').textContent;
                    const ratio = cells[3].textContent;
                    
                    // è®¾ç½®é¢œè‰²é€‰æ‹©å™¨çš„å€¼
                    color1.value = headColor;
                    color2.value = tailColor;
                    mixColorInput.value = mixedColor; // è®¾ç½®åº•éƒ¨æ··åˆé¢œè‰²é€‰æ‹©å™¨
                    
                    // æ ¹æ®æ¯”ä¾‹è®¾ç½®æ»‘å—ä½ç½®
                    const ratioValue = parseInt(ratio);
                    slider1.value = Math.max(0, ratioValue - 10);
                    slider2.value = Math.min(100, ratioValue + 10);
                    
                    // æ›´æ–°æ¸å˜å’Œé¢„è§ˆ
                    updateGradient();
                    updateColorPreview();
                    
                    // è®¾ç½®ç¼–è¾‘çŠ¶æ€
                    editingRowIndex = index;
                    confirmButton.textContent = 'æ›´æ–°';
                }
            };

            // åˆ é™¤è¡Œå‡½æ•°
            window.deleteRow = function(index) {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸€è¡Œå—ï¼Ÿåˆ é™¤åå¯¹åº”çš„canvasé¢œè‰²ä¹Ÿä¼šè¢«è¿˜åŸã€‚')) {
                    const row = colorTableBody.children[index];
                    if (row) {
                        // è·å–è¿™ä¸€è¡Œå¯¹åº”çš„å˜åŒ–ID
                        const changeId = row.getAttribute('data-change-id');
                        
                        // è¿˜åŸcanvasä¸­å¯¹åº”çš„é¢œè‰²
                        if (changeId) {
                            restoreCanvasColors(changeId);
                        }
                        
                        // åˆ é™¤è¡¨æ ¼è¡Œ
                        row.remove();
                        
                        // é‡æ–°è®¾ç½®æ‰€æœ‰è¡Œçš„onclickäº‹ä»¶ï¼Œå› ä¸ºç´¢å¼•ä¼šæ”¹å˜
                        updateRowIndices();
                    }
                }
            };

            // è¿˜åŸcanvasä¸­æŒ‡å®šå˜åŒ–IDçš„é¢œè‰²
            function restoreCanvasColors(changeId) {
                // æ‰¾åˆ°å¯¹åº”çš„å˜åŒ–è®°å½•
                const changeRecord = colorChangeHistory.find(record => record.id == changeId);
                if (!changeRecord) {
                    console.log('æœªæ‰¾åˆ°å¯¹åº”çš„é¢œè‰²å˜åŒ–è®°å½•');
                    return;
                }
                
                // è·å–å½“å‰canvasçš„å›¾åƒæ•°æ®
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                
                // è¿˜åŸæ¯ä¸ªåƒç´ çš„åŸå§‹é¢œè‰²
                changeRecord.changes.forEach(change => {
                    const index = change.index;
                    data[index] = change.originalRgb.r;     // Red
                    data[index + 1] = change.originalRgb.g; // Green
                    data[index + 2] = change.originalRgb.b; // Blue
                    // Alphaä¿æŒä¸å˜
                });
                
                // å°†è¿˜åŸåçš„å›¾åƒæ•°æ®æ”¾å›canvas
                ctx.putImageData(imageData, 0, 0);
                
                // ä»å†å²è®°å½•ä¸­ç§»é™¤è¿™ä¸ªå˜åŒ–
                const index = colorChangeHistory.findIndex(record => record.id == changeId);
                if (index > -1) {
                    colorChangeHistory.splice(index, 1);
                }
                
                // æ˜¾ç¤ºè¿˜åŸæˆåŠŸæç¤º
                let resultDiv = document.getElementById('processingResult');
                if (!resultDiv) {
                    resultDiv = document.createElement('div');
                    resultDiv.id = 'processingResult';
                    resultDiv.style.cssText = `
                        margin: 10px 0;
                        padding: 10px;
                        background: #f8d7da;
                        color: #721c24;
                        border-radius: 6px;
                        border: 1px solid #f5c6cb;
                        text-align: center;
                        font-size: 0.875rem;
                    `;
                    document.querySelector('.container').appendChild(resultDiv);
                }
                
                resultDiv.innerHTML = `ğŸ”„ å·²è¿˜åŸ ${changeRecord.changes.length} ä¸ªåƒç´ çš„åŸå§‹é¢œè‰²`;
                
                // 3ç§’åè‡ªåŠ¨éšè—æç¤º
                setTimeout(() => {
                    if (resultDiv) {
                        resultDiv.remove();
                    }
                }, 3000);
            }

            // æ›´æ–°è¡Œç´¢å¼•
            function updateRowIndices() {
                const rows = colorTableBody.children;
                for (let i = 0; i < rows.length; i++) {
                    const buttons = rows[i].querySelectorAll('button');
                    buttons[0].setAttribute('onclick', `editRow(${i})`);
                    buttons[1].setAttribute('onclick', `deleteRow(${i})`);
                }
            }

            // æ£€æŸ¥canvasæ˜¯å¦ä¸ºç©º
            function isCanvasEmpty() {
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰åƒç´ éƒ½æ˜¯é€æ˜çš„æˆ–èƒŒæ™¯è‰²
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0) { // alphaé€šé“å¤§äº0è¡¨ç¤ºæœ‰å†…å®¹
                        return false;
                    }
                }
                return true;
            }

            // åœ¨canvasä¸­æ‰¾åˆ°ä»å¤´éƒ¨é¢œè‰²åˆ°å°¾éƒ¨é¢œè‰²èŒƒå›´å†…çš„æ‰€æœ‰é¢œè‰²
            function findColorsInRange(headColor, tailColor) {
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                const colorsInRange = [];
                const colorMap = new Map(); // ç”¨äºå»é‡
                
                const headRgb = hexToRgb(headColor);
                const tailRgb = hexToRgb(tailColor);
                
                // éå†canvasä¸­çš„æ‰€æœ‰åƒç´ 
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    
                    if (a > 0) { // åªå¤„ç†éé€æ˜åƒç´ 
                        const pixelRgb = { r, g, b };
                        const pixelHex = rgbToHex(r, g, b);
                        
                        // æ£€æŸ¥è¿™ä¸ªåƒç´ é¢œè‰²æ˜¯å¦åœ¨å¤´éƒ¨é¢œè‰²åˆ°å°¾éƒ¨é¢œè‰²çš„èŒƒå›´å†…
                        if (isColorInRange(pixelRgb, headRgb, tailRgb)) {
                            if (!colorMap.has(pixelHex)) {
                                colorMap.set(pixelHex, {
                                    hex: pixelHex,
                                    rgb: pixelRgb,
                                    positions: []
                                });
                            }
                            // è®°å½•è¿™ä¸ªé¢œè‰²çš„åƒç´ ä½ç½®
                            const pixelIndex = i / 4;
                            const x = pixelIndex % imageCanvas.width;
                            const y = Math.floor(pixelIndex / imageCanvas.width);
                            colorMap.get(pixelHex).positions.push({ x, y, index: i });
                        }
                    }
                }
                
                // è½¬æ¢ä¸ºæ•°ç»„
                colorMap.forEach(color => {
                    colorsInRange.push(color);
                });
                
                return colorsInRange;
            }

            // æ£€æŸ¥é¢œè‰²æ˜¯å¦åœ¨æŒ‡å®šèŒƒå›´å†…
            function isColorInRange(pixelRgb, headRgb, tailRgb) {
                // è®¡ç®—é¢œè‰²åœ¨RGBç©ºé—´ä¸­çš„ä½ç½®
                const headToTail = {
                    r: tailRgb.r - headRgb.r,
                    g: tailRgb.g - headRgb.g,
                    b: tailRgb.b - headRgb.b
                };
                
                const pixelToHead = {
                    r: pixelRgb.r - headRgb.r,
                    g: pixelRgb.g - headRgb.g,
                    b: pixelRgb.b - headRgb.b
                };
                
                // è®¡ç®—ç‚¹ç§¯æ¥åˆ¤æ–­æ˜¯å¦åœ¨èŒƒå›´å†…
                const dotProduct = pixelToHead.r * headToTail.r + pixelToHead.g * headToTail.g + pixelToHead.b * headToTail.b;
                const headToTailLengthSquared = headToTail.r * headToTail.r + headToTail.g * headToTail.g + headToTail.b * headToTail.b;
                
                if (headToTailLengthSquared === 0) {
                    // å¦‚æœå¤´éƒ¨å’Œå°¾éƒ¨é¢œè‰²ç›¸åŒï¼Œç›´æ¥æ¯”è¾ƒ
                    return pixelRgb.r === headRgb.r && pixelRgb.g === headRgb.g && pixelRgb.b === headRgb.b;
                }
                
                // è®¡ç®—æŠ•å½±æ¯”ä¾‹
                const projectionRatio = dotProduct / headToTailLengthSquared;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨0åˆ°1ä¹‹é—´ï¼ˆåœ¨å¤´éƒ¨å’Œå°¾éƒ¨ä¹‹é—´ï¼‰
                if (projectionRatio >= 0 && projectionRatio <= 1) {
                    // è®¡ç®—åˆ°ç›´çº¿çš„è·ç¦»
                    const projectedPoint = {
                        r: headRgb.r + projectionRatio * headToTail.r,
                        g: headRgb.g + projectionRatio * headToTail.g,
                        b: headRgb.b + projectionRatio * headToTail.b
                    };
                    
                    const distance = Math.sqrt(
                        Math.pow(pixelRgb.r - projectedPoint.r, 2) +
                        Math.pow(pixelRgb.g - projectedPoint.g, 2) +
                        Math.pow(pixelRgb.b - projectedPoint.b, 2)
                    );
                    
                    // è®¾ç½®ä¸€ä¸ªå®¹å·®èŒƒå›´ï¼ˆå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰
                    const tolerance = 30;
                    return distance <= tolerance;
                }
                
                return false;
            }

            // ä»canvasä¸­æå–é¢œè‰²ä¿¡æ¯
            function extractCanvasColors() {
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                const colors = [];
                
                // é‡‡æ ·canvasä¸­çš„é¢œè‰²ï¼ˆæ¯10ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡ï¼‰
                for (let i = 0; i < data.length; i += 40) { // æ¯10ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    
                    if (a > 0) { // åªå¤„ç†éé€æ˜åƒç´ 
                        const hex = rgbToHex(r, g, b);
                        colors.push({
                            rgb: { r, g, b },
                            hex: hex
                        });
                    }
                }
                return colors;
            }

            // è®¡ç®—ä¸¤ä¸ªé¢œè‰²ä¹‹é—´çš„ç›¸ä¼¼åº¦
            function calculateColorSimilarity(color1, color2) {
                const rDiff = Math.abs(color1.r - color2.r);
                const gDiff = Math.abs(color1.g - color2.g);
                const bDiff = Math.abs(color1.b - color2.b);
                
                // ä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»è®¡ç®—ç›¸ä¼¼åº¦
                const distance = Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
                const maxDistance = Math.sqrt(255 * 255 * 3); // æœ€å¤§å¯èƒ½è·ç¦»
                
                return 1 - (distance / maxDistance); // è¿”å›0-1ä¹‹é—´çš„ç›¸ä¼¼åº¦å€¼
            }

            // å¯¹æ‰¾åˆ°çš„é¢œè‰²è¿›è¡Œæ··åˆ
            function mixColorsInRange(colorsInRange, mixColor) {
                const mixRgb = hexToRgb(mixColor);
                const mixedColors = [];
                
                colorsInRange.forEach(color => {
                    // å°†æ¯ä¸ªæ‰¾åˆ°çš„é¢œè‰²ä¸æ··åˆé¢œè‰²è¿›è¡Œæ··åˆ
                    const mixedR = Math.round((color.rgb.r + mixRgb.r) / 2);
                    const mixedG = Math.round((color.rgb.g + mixRgb.g) / 2);
                    const mixedB = Math.round((color.rgb.b + mixRgb.b) / 2);
                    
                    mixedColors.push({
                        originalHex: color.hex,
                        originalRgb: color.rgb,
                        mixedRgb: { r: mixedR, g: mixedG, b: mixedB },
                        mixedHex: rgbToHex(mixedR, mixedG, mixedB),
                        positions: color.positions
                    });
                });
                
                return mixedColors;
            }

            // å°†æ··åˆåçš„é¢œè‰²æ›´æ–°åˆ°canvasä¸Š
            function updateCanvasWithMixedColors(colorsInRange, mixedResult) {
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                let replacedPixels = 0;
                
                // è®°å½•è¿™æ¬¡é¢œè‰²å˜åŒ–çš„å†å²
                const changeRecord = {
                    id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
                    changes: []
                };
                
                // ä¸ºæ¯ä¸ªæ··åˆé¢œè‰²æ›´æ–°å¯¹åº”çš„åƒç´ 
                mixedResult.forEach(mixedColor => {
                    mixedColor.positions.forEach(position => {
                        const index = position.index;
                        
                        // è®°å½•åŸå§‹é¢œè‰²
                        const originalR = data[index];
                        const originalG = data[index + 1];
                        const originalB = data[index + 2];
                        
                        // æ›´æ–°åƒç´ é¢œè‰²
                        data[index] = mixedColor.mixedRgb.r;     // Red
                        data[index + 1] = mixedColor.mixedRgb.g; // Green
                        data[index + 2] = mixedColor.mixedRgb.b; // Blue
                        // Alphaä¿æŒä¸å˜
                        
                        // è®°å½•å˜åŒ–
                        changeRecord.changes.push({
                            index: index,
                            originalRgb: { r: originalR, g: originalG, b: originalB },
                            newRgb: mixedColor.mixedRgb
                        });
                        
                        replacedPixels++;
                    });
                });
                
                // å°†ä¿®æ”¹åçš„å›¾åƒæ•°æ®æ”¾å›canvas
                ctx.putImageData(imageData, 0, 0);
                
                // ä¿å­˜å˜åŒ–è®°å½•
                colorChangeHistory.push(changeRecord);
                
                return { replacedPixels, changeId: changeRecord.id };
            }

            // æ˜¾ç¤ºå¤„ç†ç»“æœä¿¡æ¯
            function displayProcessingResult(replacedCount) {
                // ç§»é™¤ä¹‹å‰çš„ç»“æœå±•ç¤ºåŒºåŸŸ
                const existingResult = document.getElementById('comparisonResult');
                if (existingResult) {
                    existingResult.remove();
                }
                
                // åˆ›å»ºç®€å•çš„å¤„ç†ç»“æœæç¤º
                let resultDiv = document.getElementById('processingResult');
                if (!resultDiv) {
                    resultDiv = document.createElement('div');
                    resultDiv.id = 'processingResult';
                    resultDiv.style.cssText = `
                        margin: 10px 0;
                        padding: 10px;
                        background: #d4edda;
                        color: #155724;
                        border-radius: 6px;
                        border: 1px solid #c3e6cb;
                        text-align: center;
                        font-size: 0.875rem;
                    `;
                    document.querySelector('.container').appendChild(resultDiv);
                }
                
                resultDiv.innerHTML = `âœ… å·²æˆåŠŸæ›¿æ¢ ${replacedCount} ä¸ªåƒç´ çš„é¢œè‰²åˆ°canvaså›¾ç‰‡ä¸Š`;
                
                // 3ç§’åè‡ªåŠ¨éšè—æç¤º
                setTimeout(() => {
                    if (resultDiv) {
                        resultDiv.remove();
                    }
                }, 3000);
            }

            // å›¾ç‰‡ä¸Šä¼ åŠŸèƒ½
            uploadButton.addEventListener('click', function() {
                imageUpload.click();
            });

            imageUpload.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // æ¸…ç©ºcanvas
                            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                            
                            // è®¡ç®—å›¾ç‰‡ç¼©æ”¾æ¯”ä¾‹ï¼Œä¿æŒå®½é«˜æ¯”
                            const canvasAspect = imageCanvas.width / imageCanvas.height;
                            const imageAspect = img.width / img.height;
                            
                            let drawWidth, drawHeight, offsetX, offsetY;
                            
                            if (imageAspect > canvasAspect) {
                                // å›¾ç‰‡æ›´å®½ï¼Œä»¥å®½åº¦ä¸ºå‡†
                                drawWidth = imageCanvas.width;
                                drawHeight = imageCanvas.width / imageAspect;
                                offsetX = 0;
                                offsetY = (imageCanvas.height - drawHeight) / 2;
                            } else {
                                // å›¾ç‰‡æ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                                drawHeight = imageCanvas.height;
                                drawWidth = imageCanvas.height * imageAspect;
                                offsetX = (imageCanvas.width - drawWidth) / 2;
                                offsetY = 0;
                            }
                            
                            // ç»˜åˆ¶å›¾ç‰‡åˆ°canvas
                            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                            
                            // ä¿å­˜åŸå§‹å›¾ç‰‡æ•°æ®
                            originalImageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                            
                            // æ˜¾ç¤ºæ¢å¤æŒ‰é’®
                            restoreButton.style.display = 'inline-block';
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // æ¢å¤åŸå§‹å›¾ç‰‡åŠŸèƒ½
            restoreButton.addEventListener('click', function() {
                if (originalImageData) {
                    ctx.putImageData(originalImageData, 0, 0);
                    
                    // æ˜¾ç¤ºæ¢å¤æˆåŠŸæç¤º
                    let resultDiv = document.getElementById('processingResult');
                    if (!resultDiv) {
                        resultDiv = document.createElement('div');
                        resultDiv.id = 'processingResult';
                        resultDiv.style.cssText = `
                            margin: 10px 0;
                            padding: 10px;
                            background: #d1ecf1;
                            color: #0c5460;
                            border-radius: 6px;
                            border: 1px solid #bee5eb;
                            text-align: center;
                            font-size: 0.875rem;
                        `;
                        document.querySelector('.container').appendChild(resultDiv);
                    }
                    
                    resultDiv.innerHTML = `ğŸ”„ å·²æ¢å¤åŸå§‹å›¾ç‰‡`;
                    
                    // 3ç§’åè‡ªåŠ¨éšè—æç¤º
                    setTimeout(() => {
                        if (resultDiv) {
                            resultDiv.remove();
                        }
                    }, 3000);
                }
            });

            updateGradient();
            updateColorPreview();
        });
    </script>
</body>
</html>